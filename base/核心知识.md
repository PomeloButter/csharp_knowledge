# 核心知识

## 常量

const,在生命周期中不会发生变化的变量。
```
const int a = 100;
```

常量具有以下特点：
- 常量必须在声明时初始化，指定值后不能再改变。
- const必须能在编译时用于计算。因此，不能从变量中提取的值来初始化const。
- 常量总是隐式静态的。但注意，不必（也不允许)在常量声明中包含修饰符static。
// const static int a = 100;//编译不通过

在程序中使用常量的至少三个好处:
- 使用易于理解的名称替代较难读取的数字和字符串，加强程序易读性.
	- 如 
    ```
    const int DelayTime = 100;
    ```
- 常量使程序更易于修改。
    - 上述那样，以后只需要修改DelayTime即可，而不是每个地方都去改数字
- 常量更容易避免程序出现错误。如果在其他地方赋值，会报错。

## 数据类型
C#中数据类型分为两类：
- 值类型
- 引用类型

值类型直接存储其值，引用类型存储对值的引用。

这两种类型存储在内存的不同地方：
- 值类型存储在堆栈(stack）
- 引用类型存储在托管堆上（managed heap)上。

值类型和引用类型会有不同的影响。
如下面的代码，值类型会在内存的两个地方存储值20.
```
    i = 20;
    j = 20;
```

但考虑下面的代码。
```
    Vector x,y;
    x = new Vector();
    x.Value = 30;
    y = x;
    y.Value = 50;
```
这段代码只有一个Vector对象，只有new关键字才会创建对象，声明xy两个变量只保留了一个引用，而不会实例化给定类型的对象。

因此，xy引用同一个对象，所以对x和y的修改都是对同一个对象的修改。

引用类型存储在堆中，CLR实现一种精细的算法，来跟踪那些引用变量仍是可以访问的，哪些引用变量不可以访问。

CLR回定期删除不能访问的对象，把他们占用的内存返回给OS，这是通过垃圾回收器实现的。

- 提醒：struct 是值类型

## 预定义的值类型

1. 整型
- C#中，int总是32位有符号的整数，C++的int的位数则取决于平台。
- 所有整数类型的变量都能被赋予10或16进制的值，16进制需要0x前缀

2. 浮点型
- float是32位，double是64位
- 要指定小数为float,在后面加上字符F或f
```
    float f = 12.5f;
```
3. decimal类型
- decimal类型表示精度更高的浮点数
- decimal的位数为28
- 把数字指定为decimal类型需要在后面加上m或M
```
    decimal d = 12.30M;
```

4. bool类型
- true or false

5. 字符类型
- C#支持单字符类型char，使用<code>'A'</code>单引号来括起来
- 除了把char表示为字符字面量外，还可以
    - 用4位16进制的Unicode值，如<code>'\u0041'</code>
    - 带有强制类型转换的整数值,<code>(char)65</code>
    - 或16进制数 <code>'\x0041'</code>

## 预定义的引用类型
- c#支持两种预定义的引用类型，object和string

1. object
- 在C#中,object就是最终的父类型，所有内置类型和用户定义的类型都从它派生而来。（包括值类型
- 可以使用object引用来绑定任何特定子类型的对象
- object实现了许多基本方法，包括Equals(),GetHashCode(),GetType()和ToString()。

2. string
- C#有string关键字，在遮罩下转换为.NET类System.String，有了它，像字符串连接和字符串复制这样的操作就很简单了。
- 尽管string是引用类型，string对象被分配在堆上，但是string与引用类型的常见行为有一些区别.
    - 字符串是不可改变的。修改其中一个字符串，就会创建一个全新的string对象，而另一个字符串不发生任何变化。
    - 