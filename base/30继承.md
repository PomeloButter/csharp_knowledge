# 继承
- 面向对象的三个最重要的概念是 `继承`、`封装`、`多态性`。

## 继承的类型
- 首先介绍一些面向对象(Object-Oriented OO)术语
    - 单重继承：表示一个类可以派生自一个基类。C#支持
    - 多重继承：允许一个类派生自多各类。C#不支持，但支持接口的多重继承。
    - 多层继承：多层继承允许继承由更大的层次结构。类B派生自类A，类C派生自类B。其中，类B也成为`中间基类`。C#支持
    - 接口继承：定义了接口的继承。这里允许多重继承。

### 多重继承
- 一些语言支持所谓的"多重继承"，即一个类派生自多个类。对于实现继承，多重继承会增加复杂性，还会带来开销。C#不支持
- C#支持类派生多个接口。一个类可以实现多个接口。C#类可以派生子另一个类和任意多个接口。
- 准确的说，因为System.Ojbect是公共的基类，所以每个C#类（除了Object类之外）都有一个基类，还可以有任意多个基接口。

### 结构和类
- 结构不支持继承。但是继承自动派生自System.ValueType。
- 接口可以实现接口
- 结构总是派生自System.ValueType,还可以派生自任意多个接口。
- 类总是派生自System.Object或用户选择的类，还可以派生自任意多个接口。

## 实现继承
- C#使用:后加类名实现继承(和C++类似，JAVA则需要使用关键字extend)
```
public MyDerivedClass : BaseClass
{

}
```
- 如果类也派生自接口，则用逗号分隔开基类和接口
```
public MyDerivedClass : BaseClass,Interface1,Interface2
```
- 如果类和接口都用于派生，则类必须放在接口前

- 结构的继承语法：
```
public struct MyDerivedStruct : Interface1,Interface2
{

}
```

- 如果类中没有定义基类，则C#编译器会假定System.Object是基类。因此，继承Object和不定义基类的效果是相同的。
```
class MyClass : Ojbect
{

}
=
class MyClass
{

}
```

### 虚方法
- 把一个基类方法声明为 `virtual` ，就可以在任何派生类中重写该方法:
```
public class Shape{
    public virtual void Draw(){
        WriteLine("this is shape");
    }
}
```

- 也可以把属性声明为 `virtual` （毕竟属性其实就是方法）
```
public virtual int Size {get; set;}
```

- 当然也可以使用完整的属性语法
```
private int _size;
public int Size{
    get {
        return _size;
    }
    set{
        _size = value;
    }
}
```

- C#中虚函数的概念与标准OOP的概念相同：可以在派生类中重写虚函数。在调用方法时，会调用该类对象的合适方法。在C#中，除了构造函数意外都可以显式地声明为 `virtual`。这遵循C++的方式。而在JAVA中，所有函数都是虚拟的。
- C#要求重写函数时使用 `override` 关键字显式声明。
```
public class Rectangle : Shape
{
    public override void Draw() => WriteLine("this is Rectangle");
}
```
- 重写方法的语法避免了C++中很容易发生的潜在运行错误：当派生类的方法签名无意中与基类版本略有差别时，该方法就不能重写基类的方法。在C#中，这会编译错误。
- Size重写了ToString方法，这个方法在基类Object中声明为 virtual
```
public class Size{
    public override string ToString() => "Size";
}
```
- 重写方法时，签名和返回类型必须匹配。
- 成员字段和静态函数都不能声明为virtual,因为这个概念支队类中的实例函数成员有意义。

### 多态性
- 使用多态性，可以动态地定义调用的方法，而不是在编译器间定义。编译器创建一个虚拟方法表(vtable)，其中列出了可以在运行期间调用的方法，它根据运行期间的类型调用方法。
```
//Shape 基类
//triangle Rectangle 继承Shape,而且均重写了Draw
//square 继承shape，没有重写shape的Draw
public class Shape{
    public virtual void Draw() => "Shape";
}
public class Triangle : Shape
{
    public override void Draw() => "Triangle";
}
public class Rectangle : Shape
{
    public override void Draw() => "Rectangle";
}
public class Square : Shape
{

}

public static void Main(){
    Shape s1 = new Shape();
    Shape s2 = new Triangle();
    Shape s3 = new Rectangle();
    Shape s4 = new Square();
    s1.Draw();//Shape
    s2.Draw();//Triangle
    s3.Draw();//Rectangle
    s4.Draw();//Shape
}
```
- 可以看到，程序会根据其真正的类型来调用方法，如果基类的方法不是虚拟方法或没有重写派生类的方法，就是用所声明对象的类型的Draw()方法。如果时虚拟方法且重写了，就调用对象真正的类型的Draw方法。

### 隐藏方法
- 如果签名相同的方法在基类和派生类中都声明了，但没有声明为virtual和override,派生类就会隐藏基类方法。
- 在大多数情况，是要重写方法，而不是隐藏方法。
- 假定有一个基类Shape,在将来的某一个时刻，要编写一个派生类Ellipse，用它给Shape添加某个功能，特别是要添加当前基类没有的方法 MoveBy();
- 过了一段时间，基类的编写者决定扩展基类，为了保持一致，他也添加了一个名为MoveBy()的方法，该方法的名称和签名与前面的一致。
- 假设基类的MoveBy声明为虚方法，由于子类方法没有用override关键字，编译器假定子类的MoveBy时一个完全不同的方法,只是名字相同，和基类完全没关系。
```
    public class Shape
    {
        public virtual void Draw() => Console.WriteLine("Shape"); 
    }
    public class Triangle : Shape
    {
        public void Draw() => Console.WriteLine("Triangle");
    }
    static void Main(string[] args)
    {
        Shape s1 = new Shape();
        Shape s2 = new Triangle();
        s1.Draw();//Shape
        s2.Draw();//Shape
    }
```
- 这样写代码会出现编译器错误，我们可以使用 `new` 关键字来隐藏方法。
```
    public class Triangle : Shape
    {
        new public void Draw() => Console.WriteLine("Triangle");
    }
```
- new方法不应该故意用于隐藏基类的成员。主要目的是处理版本冲突。

### 调用方法的基类版本
- C#有一种特殊语法从子类中调用方法的基类版本： `base.MethodName()` 。
```
public class Shape
{
    public virtual void Draw() => Console.WriteLine("Shape");
}
public class Triangle : Shape
{
    public override void Draw()
    {
        base.Draw();
        Console.WriteLine("Triangle");
    }
}
```
---
### 抽象类和抽象方法
- C#允许把类和方法声明为 `abstract`。抽象类不能实例化，而抽象方法不能直接实现，必须在非抽象的派生类中重写。显然，抽象方法本身也是虚拟的（尽管不需要也不能提供virtual关键字）。如果类包含抽象方法，则该类也是抽象的，必须声明为抽象。

- 下面把Shape类改为抽象类。
```
public abstract class Shape{
    public abstract void Darw();
}

public class Rectangle : Shape
{
    public override void Draw() => WriteLine("Rectangle");
}
```
- 从抽象基类中派生类型时，必须实现所有抽象成员，否则会报错。

- 使用抽象的Shape类和派生的Rectangle类，可以声明Shape的一个变量。不能实例化它，但是可以实例化Rectangle，并分配给Shape变量.
```
//Shape shape = new Shape();
//不可以，无法做到
Shape shape = new Rectangle();
shape.Draw();
```

### 密封类和密封方法
- 如果希望每个类不被继承，该类就应密封。给类添加 `sealed` 修饰符，就不允许创建该类的子类。
- 密封一个方法，表示不能重写该方法。（只能用于子类）
- 要在方法或属性上使用 `sealed` 关键字，必须先从基类上把它声明为要重写的方法或属性。如果基类上不希望有重写的方法或属性，就不要把它声明为 `virtual`。
```
public sealed class BaseClass
{

}
public class MyClass : BaseClass // 报错 无法从密封类中派生
{

}

//密封方法
public class Shape
{
    public virtual void Draw() => Console.WriteLine("Shape");
}
public class Triangle : Shape
{
    public sealed override void Draw() => Console.WriteLine("Triangle");

}
public class RightTriangle: Triangle
{
    // Draw是密封的，无法重写
    public override void Draw() => Console.WriteLine("Right Triangle");
}

```
- 密封类有另一个原因。对于密封类，编译器知道不能派生类，因此用于虚拟方法的虚拟表可以缩短或消除，以提高性能。
- string类是密封的。没有哪个应用程序不适用字符串，最好使这种类型保持最佳性能。把类标记为sealed 怼编译器来说是一个很好的提示。
- 将一个方法声明为sealed的目的类似于一个类。编译器知道，另一个类不能扩展这个方法的虚拟表，他在这里终止继承。

### 派生类的构造函数
- 
p110
