# 托管和非托管资源
<!-- TOC -->

- [托管和非托管资源](#托管和非托管资源)
    - [资源](#资源)
    - [后台内存管理](#后台内存管理)
        - [值数据类型](#值数据类型)
        - [引用数据类型](#引用数据类型)
        - [垃圾回收](#垃圾回收)
    - [强引用和弱引用](#强引用和弱引用)
    - [处理非托管资源](#处理非托管资源)
        - [析构函数或终结器](#析构函数或终结器)
        - [IDisposalbe接口](#idisposalbe接口)
        - [using语句](#using语句)
        - [实现IDispose接口和析构函数](#实现idispose接口和析构函数)
        - [IDispose和终结器的规则](#idispose和终结器的规则)
    - [不安全的代码](#不安全的代码)

<!-- /TOC -->
## 资源
- 使用托管和非托管的资源——存储在托管或本机堆中的对象。
- 尽管垃圾收集器释放存储在托管堆中的托管对象，但不释放本机堆中的对象。必须由开发人员自己释放它们。

- 使用托管环境时，很容易被误导，注意不到内存管理。因为垃圾收集器(GC)会处理它。

- 很多工作都由GC完成
    - 了解他是如何工作的
    - 什么是大小对象堆
    - 什么数据类型存储在堆栈上
- 非常有益

- 同时，垃圾收集器处理托管的资源，非托管的需要开发人员释放。

- 程序可能是完全托管的程序，但是框架的类型呢？
- 例如，文件类型包装了一个本地文件句柄。这个句柄需要释放，为了尽早释放这个句柄，最好了解IDisposable接口和using语句。

- 本章介绍内存管理和内存访问的各个方面。如果很好地理解了内存管理和C#提供的指针功能，也就能很好地集成C#代码和原来的代码，并能在非常注重性能的系统中高效地处理内存。

## 后台内存管理

### 值数据类型
- windows使用一个虚拟寻址系统，该系统把程序可用的内存地址映射到硬件内存中的实际地址上，这些人物完全由windows在后台管理。

- 实际结果是32位处理器上每个进程都可以使用4GB内存（无论实际上有多少物理内存）（64位处理器上，这个数字会更大）。

- 这个4GB内存实际上包含了程序的所有部分，包括
    - 可执行代码
    - 代码加载的所有DLL
    - 程序运行时使用的所有变量的内容

- 这个4GB的内存称为虚拟地址空间，或虚拟内存。为了方便起见，本章简称为内存。

- 4GB中的每个存储单元都是从0开始往上排序的。要访问内存的值，就要提供表示该存储单元的数字。

- 在处理器的虚拟内存中，有一个区域称为栈。栈存储 `不是对象成员` 的值数据类型。另外，在调用一个方法时，也使用栈存储传递给方法的所有参数的副本。
    - 为了理解栈的工作原理，注意在C#中的变量作用域。
    - 如果变量a在变量b之前进入作用域，b就会首先超出作用域。（栈先进后出
    ```
    {
        int a;
        {
            int b;
        }
    }
    ```
    - 释放变量时，顺序总是与给它们分配内存的顺序相反，这就是栈的工作方式。

- 栈指针（操作系统维护的变量）表示栈中下一个空闲存储单元的地址。
    - 栈指针指向向栈保留的内存块末尾。
    - 栈实际上是向下填充的，即从高内存地址向地内存地址填充。
    - 当数据入栈后，栈指针会随之调整，始终指向下一个空闲单元。

    - 一个存储单元就是一个字节，下面是一个实例：
    ```
    {
        int num = 10;
        double dnum = 20.9;
    }
    ```
    - 花括号代表了作用域，声明了两个变量，下面是栈的工作过程：
        1. 首先假设栈指针当前指向 `80000`的存储单元，进入作用域块

        2. 声明了一个int 型的变量，赋值为10, int型占4个字节，栈指针从上往下填充，即栈指针的值-4，`80000-4=79996`, 栈指针当前指向`79996`,即下一个空闲单元(79995)

        3. 下一行代码声明了一个 `double` 型变量，初始化为 20.9， double型变量占8个字节，因此栈指针-8， 当前栈指针指向  `79988` 。

        4. 作用域结束，先进后出原则，释放double的内存空间， 栈指针+8，指向 `79996`， 然后int也释放，栈指针+4，指向 `80000` 。

- 如果编译器遇到`int i , j` 这样的代码行，则这两个变量进入作用域的顺序是不确定的。两个变量是同时声明的，也是同时超出作用域的。此使，变量以什么顺序从内存中删除就不重要了。
- 编译器内部会确保先放进内存的变量后删除(栈)，确保该规则不会与变量的生存期冲突。


### 引用数据类型

- 尽管栈由非常高的性能，但它还没有灵活到可以用于所有的变量。变量的生存期必须嵌套，在等许多情况下，这种要求都过于苛刻。

- 通常我们希望使用一个方法分配内存，来存储一些数据，并在方法退出后的很长一段时间内数据仍是可用的。只要是使用 new 运算符来请求分配存储空间，就存在这种可能性——例如，对于所有的引用类型。此使就要使用托管堆。

- 托管堆(简称堆)是处理器的可用内存中的另一个内存区域。要了解堆的工作原理和如何为引用数据类型分配内存，看看下面的代码：
```
void DoWork(){
    Customer c;
    c = new Customer();
    Customer c2 = new OtherCustomer();
}
```

- 这段代码中，假定存在两个类Customer和OtherCustomer，OtherCustomer继承Customer。

- 首先，声明一个Customer引用 `c1` ，在栈上给这个引用分配存储空间，但这仅是一个引用，而不是实际的Customer对象。 c1 引用占用4字节的空间，足够包含Customer对象的存储地址。（需要4个字节把0~4GB之间的内存地址表示为一个整数）。

- 然后看下一行代码：
```
c = new Customer();
```

- 这行代码完成了以下操作：
    1. 分配堆上的内存，以存储Customer对象(一个真正的对象，而不只是一个地址)。
    2. 把变量c1的值设置为分配给新Customer对象的内存地址。

- Customer实例没有放在栈中，而是放在堆中。在这个例子中，假设Customer对象占32个字节。包含了Customer的实例字段，和 `.NET` 用于识别和管理其类实例的一些信息。

- 为了在堆上找到存储新Customer对象的一个存储位置，`.NET`运行库在堆中搜索，选取第一个未使用的且包含32个字节的连续块。假定其地址为 `20000`，c1引用占用栈中的第 `79996~79999`位置。

- 给Customer对象分配空间后，堆中`20000~20031`被使用。和栈不同，堆上的内存是向上分配的。

- 下一行代码声明了一个Customer引用，并实例化一个Customer对象。在这个例子中，用一行代码在栈上为c2引用分配空间，同时在堆上为OtherCustomer对象分配空间。

- 该行把栈上4个字节分配给c2引用，它存储在`79992~79995`位置上。而OtherCustomer对象在堆上从`20032`开始向上分配空间。

- 可以看到，建立引用变量的过程比建立值变量的过程更复杂。

- 把一个引用变量的值赋予另一个相同类型的变量，就有两个变量引用内存中的同一对象。当一个引用变量超出作用域时，它会从栈中删除，但引用对象的数据仍保留在堆中，直到程序终止或垃圾回收器删除它。

- 只有在该数据不再被任何变量引用时，他才会被删除。

### 垃圾回收
- 托管堆的工作方式非常类似于栈，对象会在内存中一个挨一个地放置。这样就很容易使用指向像一个空闲存储单元的堆指针来确定下一个对象的位置。在堆上添加更多对象时，也容易调整。但这比较复杂，因为基于堆的对象的生存期于引用他们的基于栈的变量的作用域不匹配。

- 在垃圾回收器运行时，他会从堆中删除不再引用的所有对象。
    
    - 垃圾回收器在引用的根表中找到所有引用的对象，接着在引用的对象树种查找。
    - 完成删除操作后，堆会立即把对象分散开来，与已经释放的内存混合在一起。

- 如果托管的堆是这样，给新对象分配内存就是一个很难处理的过程，运行库必须搜索整个堆才能找到足够大的内存块放对象。

- 所以，垃圾回收器不会让堆处于这种状态。只要他释放了能释放的所有对象，就会把其他对象移动回堆的端部，再次形成一个连续的内存块。

- 因此，堆可以继续像栈那样确定在什么地方存储新对象。

- 当然，移动对象时，对象的所有引用都需要用正确的新地址来更新，垃圾处理器会处理这个问题。

- 垃圾回收器的这个压缩操作时托管的堆和非托管的堆的区别所在。使用托管的堆，就只需要读取堆植着你的值即可，而不需要遍历地址的链表，来查找一个地方放新数据。

```
注意，一般情况下，垃圾回收器在.NET运行库确定需要进行垃圾回收时运行。
可以调用System.GC.Collect()方法，强迫垃圾回收器在代码的某个地方运行。
但是，GC类适合的场合很少，垃圾回收器的逻辑不能保证在一次垃圾收集过程中，所有为引用的对象都从堆中删除。
```

```
在测试过程中运行GC时很有用的。这样，就可以看到应该回收的对象仍然未回收而导致的内存泄漏。
因为GC的工作做得很好，所以不要在生产代码中以编程方式回收内存。如果以编程方式调用Collect，对象会更快移入下一代，如下所示。这将导致GC运行更多的时间。
```
- 创建对象时，会把这些对象放在托管堆上。堆的第一部分称为第0代。创建新对象时，会把他们移动到堆的这部分中。因此，这里驻留了最新的对象。

- 对象会继续放在这个部分，直到垃圾回收过程的第一次进行回收。这个清理过程之后仍保留的对象会被压缩，然后移动到堆的下一部分上或世代部分——第1代对应的部分。

- 此时，第0代对应的部分为空，所有的新对象都再次放到这一部分上。在垃圾回收过程中遗留下来的旧对象放在第1代对应的部分上。老对象的这种移动会再次发生。接着重复下一次回收过程。这意味着，第1代中再垃圾回收过程中遗留下来的对象会移动到堆的第2代，位于第0代的对象会移动到第1代，第0代仍用于放置新对象。

- 总结过程如下：
    1. 创建对象，对象位于第0代
    
    2. 垃圾回收启动，清理后遗留的对象移动到第1代，第0代变空

    3. 创建新对象，对象位于第0代

    4. 再次垃圾回收，遗留对象移动到第1代，第1代的遗留对象移动到第2代

```
在给对象分配内存空间时，如果超出了第0代对应的部分的容量，或者调用了GC.Collect()方法，就会进行垃圾回收。
```

- 这个过程极大地提高了应用程序的性能。一般而言，最新的对象通常时可以回收的对象，而且可能也会回收大量比较新的对象。如果这些对象在堆中的位置是相邻的，垃圾回收过程就会更快。另外，相关对象相邻放置也会使程序执行得更快。

- `.NET`中，垃圾回收提高性能的另一个领域是架构处理堆上较大对象的方式。在`.NET`下，较大对象又自己的托管堆，称为 `大对象堆`。使用大于 `85 000`个字节的对象时，他们就会放在这个特输的堆上，而不是主堆上。`.NET`应用程序不知道两者的区别，因为这是自动完成的。其原因是在堆上压缩大对象比较昂贵，因此驻留在大对象堆上的对象不执行压缩过程。

- 在进一步改进垃圾回收过程后，第2代和大对象堆上的回收现在放在后台线程上进行。这表示，引用程序线程仅会为第0代和第1代的回收而阻塞，减少了总暂停时间。对于大型服务器引用程序尤其如此。服务器和工作站默认打开这个功能。

- 有助于提高应用程序性能的另一个优化是垃圾回收的平衡，他专用于服务器的垃圾回收。服务器一般有一个线程池，执行大致相同的工作。内存分配在所有线程上都是类似的。对于服务器，每个逻辑服务器都有一个垃圾回收堆。因此其中一个堆用尽了内存，出发了垃圾回收过程时，所有其他堆也可能会得益于垃圾的回收。如果一个线程使用的额内存远远多于其他线程，导致垃圾回收，其他线程可能不需要垃圾回收，这就不是很高效。 垃圾回收过程会平很给这些堆——小对象堆和大对象堆。进行这个平衡过程，可以减少不必要的回收。

---
## 强引用和弱引用

- 垃圾回收器不能回收仍在引用的对象的内存——这是一个强引用。他可以回收不在根表中直接或间接引用的托管内存。然而，有时可能会忘记释放引用。
```
如果对象互相引用，但没有在根表中引用。如对象A引用B，B引用C，C引用A，则GC可以销毁所有这些对象。
```

- 在引用程序代码内实例化一个类或结构时，只要有代码引用它，就会形成强引用。
```
var student = new Student();
```

- 这意味着GC不会清理Student对象使用的内存。一般而言是好事，因为可能需要访问Student对象。

- 但有时候我们会创建缓存对象，引用其他对象:
```
var cache = new Cache();
cache.Add(student);
```
- 现在使用完student了，可以超出作用域或设置为null
```
student = null;
```

- 如果GC现在运行，就不能使用student引用的内存，因为他在缓存对象中引用。这样的引用很容易忘记，使用WeakReference可以避免这种情况。
```
使用事件很容易错过引用的清理，此时也可以使用弱引用。
```

- 弱引用创建和使用对象，但是GC碰巧在运行，就会回收对象并释放内存。由于存在潜在的bug和性能问题，一般不会这么用，但是特定情况下使用弱引用是合理的。

- 弱引用对小对象没有意义，因为弱引用有自己的开销，这个开销可能是比小对象大的。

- 弱引用使用 `WeakReference` 类创建。使用构造函数，就可以传递强引用。
```
WeakReference weak = new WeakReference(new Student("test"));
bool isAlive = weak.IsAlive ;
var target = weak.Target;
```
- 主要有两个属性
    - IsAlive标记对象是否已被垃圾回收。
    - Target可以尝试获取对象，如果是null说明已被回收。获取后就可以使用强引用，这时候就不能被垃圾回收了。

---
## 处理非托管资源
- GC不知道如何释放非托管的资源(例如，文件句柄、网络连接和数据库连接)。托管类在封装对非托管资源的直接或间接引用时，需要制定专门的规则，确保非托管的资源再回首类的一个实例时释放。

- 有两种机制来自动释放非托管的资源。通常一起实现，因为他们提供了略微不同的解决方案。
    - 声明一个析构函数(或终结器)，作为类的一个成员。
    - 在类中实现System.IDisposable 接口

### 析构函数或终结器
-  在GC销毁对象之前，可以调用析构函数。由于执行这个操作，因此析构函数初看似乎是放置释放非托管资源、执行一般清理操作的代码的最佳地方。但是，事情并不是这么简单。
```
在讨论C#中的析构函数时，在底层的.NET体系结构中，这些函数称为终结器(finalizer)。在C#定义析构函数时，编译器发送给程序集的实际上是Finalize()方法。
```

- C#的析构函数和C++语法一致：
```
class MyClass
{
    ~MyClass(){

    }
}
```

- C#编译器在编译析构函数时，会隐式吧析构函数的代码便以为等价于重写Finalize()方法啊的代码，从而确保执行父类的Finalize()方法。 生成的IL如下：
```
protected override void Finalize(){
    try{
        // implementation
    }
    finally{
        base.Finalize();
    }
}
```
- C#的析构函数的问题在于，你不知道什么时候调用。因为GC运行的时候才会运行析构函数。
- 另一个问题是，C#析构函数的实现会延迟对象最终从内存中删除的时间。没有析构函数的的对象会在GC的一次处理中删除，有析构函数的对象需要两次：第一次调用析构函数，第二次才删除对象。

### IDisposalbe接口

- 在C#中，推荐使用System.IDisposable 接口替代析构函数。

- IDisposable 接口定义了一种模式（具有语言级的支持），该模式为释放非托管的资源提供了确定的机制。并避免产生析构函数固有的与GC相关的问题。IDisposable接口声明了一个Dispose()方法，它不带参数，返回void。
```
class MyClass: IDisposable
{
    public void Dispose(){

    }
}
```

- Dispose()方法的实现代码显式地释放由对象直接使用的所有非托管资源，并在所有页实现IDisposable接口的封装对象上调用Dispose()方法。这样，Dispose()方法为何时释放非托管资源提供了精确的控制。

- 假定有一个DisTest 类，需要使用某些外部资源，且实现了IDispose接口，释放代码如下：
```
var instance = new DisTest();

instance.Dispose();
```
- 如果处理过程异常，就不会释放资源，这时候需要加上try
```
DisTest instance = null;
try{
    //
}
finally{
    instance?.Dispose();
}
```

### using语句
- 使用try/finally容易混淆。C#提供了using语句，可以确保在实现IDispose接口的对象的引用超出作用域时，自动调用Dispose()方法。该语句生成与try块等价的IL代码：
```
using (var instance = new DisTest()){
    //do something
}
```
```
.NET Framework中的几个类有Close和Dispose方法，如果常常要关闭资源，就实现Close和Dispose方法。此时Close方法指示调用Dispose方法。这种方法在类的使用上比较清晰，还支持using语句。新类只实现了Dispose方法，因为我们已经习惯了它。
```

### 实现IDispose接口和析构函数
- 释放非托管资源的两种方式：
    - 例用析构函数。但析构函数执行不确定，且增加系统开销
    - 例用IDispose接口，但需要确保调用Dispose()方法

- 如果创建了终结器，就应该实现IDisposable接口。假定大多数程序员都能正确调用Dispose方法，同时把实现析构函数作为一种安全机制，以防没有调用Dispose()方法。

```
public class ResourceHolder : IDisposable
{
    //用于判断是否已经Dispose过了
    private bool isDisposed = false;
    public void Dispose()
    {
        //释放资源
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    /// <summary>
    /// 真正的Dispose方法
    /// 因为析构函数调用的话托管资源可能已经被释放了，
    /// 所以要判断，当Dispose调用时才释放托管资源
    /// 非托管资源都要释放
    /// </summary>
    /// <param name="disposing">判断是析构函数调用还是Dispose调用，true代表Dispose调用</param>
    protected virtual void Dispose(bool disposing)
    {
        //如果调用过了
        if (!isDisposed)
        {
            //说明是Dispose调用的，可以在这里释放托管资源
            if (disposing)
            {
                //释放托管资源
            }

            //释放非托管资源

            //已经释放过了，避免二次释放
            isDisposed = true;
        }

    }
    /// <summary>
    /// 析构函数
    /// </summary>
    ~ResourceHolder()
    {
        Dispose(false);
    }
    public void Method()
    {
        //如果已经释放了资源就抛出错误
        if (isDisposed)
        {
            throw new ObjectDisposedException("ResourceHolder");
        }
        //do something
    }
}
```
- 实现两个方法的重点时确保所有清理代码都放在一个地方。
- 实现一个重载的Dispose主要是为了判断到底是谁调用的
    - 使用者调用，就把托管和非托管资源一起清理
    - 终结器调用，则只清理非托管资源，因为托管资源由GC来处理

- 最后，Dispose方法调用GC.SuppressFinalize()方法。该方法告诉GC有一个类不再需要调用其析构函数了。
    - 因为已经手动把托管和非托管都回收了。
    - SupressFinalize()意味着GC认为这个对象没有析构函数。

### IDispose和终结器的规则

1. 如果类定义了实现IDisposable的成员，该类也应该实现IDisposable

2. 实现了IDisposable不意味着要实现终结器。因为终结器会带来额外开销。

3. 实现了终结器应该也实现IDisposable。这样可以早点释放资源。

4. 终结器中不能访问已终结对象。

## 不安全的代码
p135
- 以后在看
